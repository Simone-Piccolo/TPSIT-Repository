<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Esercizio Scheduling</title>
  <style>
    body {
      font-family: "Segoe UI", Roboto, sans-serif;
      background: #111;
      color: #f0f0f0;
      margin: 2rem;
    }
    h1, h2 {
      color: #00b4ff;
      text-align: center;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      margin: 1rem 0;
      background: #222;
    }
    th, td {
      border: 1px solid #444;
      padding: 8px;
      text-align: center;
    }
    th {
      background: #333;
    }
    .gantt {
      display: flex;
      margin: 10px 0;
      background: #222;
      border-radius: 6px;
      overflow: hidden;
    }
    .task {
      display: flex;
      justify-content: center;
      align-items: center;
      color: #000;
      font-weight: bold;
      border-right: 1px solid #000;
      transition: transform 0.2s;
    }
    .task:hover {
      transform: scale(1.05);
    }
    .controls {
      text-align: center;
      margin-bottom: 1rem;
    }
    button {
      background: #00b4ff;
      border: none;
      color: #fff;
      padding: 10px 15px;
      margin: 0 5px;
      border-radius: 6px;
      cursor: pointer;
      font-weight: bold;
    }
    button:hover {
      background: #008acc;
    }
  </style>
</head>
<body>
  <h1>üí° Esercizio Scheduling</h1>

  <div class="controls">
    <label>Numero di task:</label>
    <input id="numTasks" type="number" min="2" max="20" value="5">
    <button onclick="simula()">Simula</button>
  </div>

  <div id="output"></div>

  <script>
    // ====== Utility ======
    function generaTask(n = 5) {
      const tasks = [];
      for (let i = 0; i < n; i++) {
        tasks.push({
          id: "P" + (i + 1),
          arrivalTime: Math.floor(Math.random() * 10),
          burstTime: Math.floor(Math.random() * 10) + 1,
          priority: Math.floor(Math.random() * 5) + 1
        });
      }
      return tasks.sort((a, b) => a.arrivalTime - b.arrivalTime);
    }

    function color(i) {
      const colors = ["#ffb703","#8ecae6","#90be6d","#f94144","#f8961e","#43aa8b","#577590"];
      return colors[i % colors.length];
    }

    // ====== Metriche comuni ======
    function calcolaMetriche(schedule) {
      let currentTime = 0, waitingSum = 0, turnaroundSum = 0;

      schedule.forEach(task => {
        if (currentTime < task.arrivalTime) currentTime = task.arrivalTime;
        task.startTime = currentTime;
        task.finishTime = currentTime + task.burstTime;
        task.turnaround = task.finishTime - task.arrivalTime;
        task.waiting = task.turnaround - task.burstTime;
        currentTime += task.burstTime;
        waitingSum += task.waiting;
        turnaroundSum += task.turnaround;
      });

      return {
        schedule,
        avgWaiting: (waitingSum / schedule.length).toFixed(2),
        avgTurnaround: (turnaroundSum / schedule.length).toFixed(2)
      };
    }

    // ====== Algoritmi ======
    function fcfs(tasks) {
      const schedule = [...tasks].sort((a, b) => a.arrivalTime - b.arrivalTime);
      return calcolaMetriche(schedule);
    }

    function sjf(tasks) {
      const queue = [...tasks];
      const schedule = [];
      let currentTime = 0;

      while (queue.length > 0) {
        const available = queue.filter(t => t.arrivalTime <= currentTime);
        if (available.length === 0) { currentTime++; continue; }
        const shortest = available.reduce((a, b) => a.burstTime < b.burstTime ? a : b);
        queue.splice(queue.indexOf(shortest), 1);
        schedule.push(shortest);
        currentTime += shortest.burstTime;
      }

      return calcolaMetriche(schedule);
    }

    function priority(tasks) {
      const queue = [...tasks];
      const schedule = [];
      let currentTime = 0;

      while (queue.length > 0) {
        const available = queue.filter(t => t.arrivalTime <= currentTime);
        if (available.length === 0) { currentTime++; continue; }
        const highest = available.reduce((a, b) => a.priority < b.priority ? a : b);
        queue.splice(queue.indexOf(highest), 1);
        schedule.push(highest);
        currentTime += highest.burstTime;
      }

      return calcolaMetriche(schedule);
    }

    function rr(tasks, quantum = 3) {
      const ready = [...tasks].sort((a, b) => a.arrivalTime - b.arrivalTime);
      const queue = [];
      const execution = [];
      let time = 0;

      while (ready.length > 0 || queue.length > 0) {
        while (ready.length > 0 && ready[0].arrivalTime <= time) queue.push(ready.shift());
        if (queue.length === 0) { time++; continue; }

        const t = queue.shift();
        if (!t.remaining) t.remaining = t.burstTime;

        const slice = Math.min(t.remaining, quantum);
        execution.push({ id: t.id, start: time, end: time + slice });
        t.remaining -= slice;
        time += slice;

        while (ready.length > 0 && ready[0].arrivalTime <= time) queue.push(ready.shift());
        if (t.remaining > 0) queue.push(t);
        else {
          t.finishTime = time;
          t.turnaround = t.finishTime - t.arrivalTime;
          t.waiting = t.turnaround - t.burstTime;
        }
      }

      const avgWaiting = (tasks.reduce((s,t)=>s+t.waiting,0)/tasks.length).toFixed(2);
      const avgTurnaround = (tasks.reduce((s,t)=>s+t.turnaround,0)/tasks.length).toFixed(2);

      return { schedule: tasks, execution, avgWaiting, avgTurnaround };
    }

    // ====== Rendering ======
    function renderGantt(executions, title) {
      const gantt = document.createElement("div");
      gantt.className = "gantt";

      executions.forEach((e, i) => {
        const div = document.createElement("div");
        div.className = "task";
        div.style.background = color(i);
        div.style.width = (e.end - e.start) * 30 + "px";
        div.innerText = e.id;
        gantt.appendChild(div);
      });

      const label = document.createElement("h3");
      label.textContent = title;
      label.style.textAlign = "center";
      const container = document.createElement("div");
      container.appendChild(label);
      container.appendChild(gantt);
      return container;
    }

    function renderTabella(tasks, algo, avgW, avgT) {
      let html = `<h2>${algo}</h2><table><tr><th>ID</th><th>Arrivo</th><th>Burst</th><th>Priorit√†</th><th>Waiting</th><th>Turnaround</th></tr>`;
      tasks.forEach(t=>{
        html += `<tr><td>${t.id}</td><td>${t.arrivalTime}</td><td>${t.burstTime}</td><td>${t.priority}</td><td>${t.waiting ?? "-"}</td><td>${t.turnaround ?? "-"}</td></tr>`;
      });
      html += `</table><p>‚è±Ô∏è Tempo medio di attesa: <b>${avgW}</b> | üîÅ Turnaround medio: <b>${avgT}</b></p>`;
      return html;
    }

    // ====== Simulazione principale ======
    function simula() {
      const n = parseInt(document.getElementById("numTasks").value);
      const tasks = generaTask(n);
      const out = document.getElementById("output");
      out.innerHTML = "";

      const algorithms = [
        { name: "FCFS", fn: fcfs },
        { name: "SJF", fn: sjf },
        { name: "PRIORITY", fn: priority },
      ];


      const rrRes = rr(JSON.parse(JSON.stringify(tasks)), 3);
      out.appendChild(renderGantt(rrRes.execution, "Round Robin (quantum=3)"));
      out.innerHTML += renderTabella(rrRes.schedule, "Round Robin", rrRes.avgWaiting, rrRes.avgTurnaround);

      algorithms.forEach(algo => {
        const res = algo.fn(JSON.parse(JSON.stringify(tasks)));
        out.appendChild(renderGantt(res.schedule.map(t=>({
          id:t.id,start:t.startTime,end:t.finishTime
        })), algo.name));
        out.innerHTML += renderTabella(res.schedule, algo.name, res.avgWaiting, res.avgTurnaround);
      });
    }

    // Esegui simulazione all‚Äôavvio
    simula();
  </script>
</body>
</html>

</body>
</html>

